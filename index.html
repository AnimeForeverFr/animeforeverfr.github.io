<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Anime Forever</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@400;700&display=swap');
    :root { --bg:#0d0d0d; --card:#1a1a1a; --accent:#ff3d00; --muted:#ccc; --success:#4caf50; --error:#f44336; }
    body{margin:0;font-family:'Nunito Sans',sans-serif;background:var(--bg);color:#f0f0f0}
    header{background:var(--card);padding:1rem;display:flex;justify-content:space-between;align-items:center}
    header h1{color:var(--accent);margin:0}
    nav button{background:var(--accent);border:none;color:#fff;padding:.5rem 1rem;border-radius:6px;cursor:pointer;margin-left:0.5rem;}
    nav button:hover{opacity:0.9;}
    main{padding:1rem}
    .series-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:1rem}
    .card{background:var(--card);padding:1rem;border-radius:10px;box-shadow:0 2px 6px rgba(0,0,0,.5)}
    img.series-img{width:100%;height:140px;object-fit:cover;border-radius:6px}
    .episode{background:#222;padding:.5rem;border-radius:6px;margin-bottom:.5rem;display:flex;justify-content:space-between;align-items:center}
    input,select,textarea{width:100%;padding:.5rem;border-radius:6px;border:none;margin:.4rem 0;box-sizing:border-box;background:#333;color:white;}
    .btn{background:#00bfa5;color:#fff;border:none;padding:.6rem 1rem;border-radius:6px;cursor:pointer;transition:opacity 0.2s;}
    .btn:hover{opacity:0.9;}
    .btn:disabled{opacity:0.6;cursor:not-allowed;}
    .danger{background:#e53935}
    .success{background:var(--success)}
    .muted{color:var(--muted)}
    .error{color:var(--error)}
    .success{color:var(--success)}
    .hidden{display:none}
    .top-right{position:fixed;right:1rem;top:1rem;z-index:2000;display:flex;align-items:center;gap:0.5rem;}
    .modal{position:fixed;left:50%;top:50%;transform:translate(-50%, -50%);width:90%;max-width:400px;background:#1a1a1a;padding:2rem;border-radius:8px;z-index:9999;box-shadow:0 0 20px rgba(0,0,0,0.7);}
    .modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:9998;}
    .auth-tabs{display:flex;margin-bottom:1rem;border-bottom:1px solid #333;}
    .auth-tab{padding:0.5rem 1rem;cursor:pointer;border-bottom:2px solid transparent;}
    .auth-tab.active{color:var(--accent);border-bottom-color:var(--accent);}
    .auth-form{display:block;}
    .auth-form.hidden{display:none;}
    .loading{opacity:0.6;pointer-events:none;}
  </style>
</head>
<body>
  <!-- auth modal -->
  <div id="authModal" class="modal hidden">
    <div class="auth-tabs">
      <div class="auth-tab active" id="loginTab">Connexion</div>
      <div class="auth-tab" id="registerTab">Inscription</div>
    </div>

    <div id="loginForm" class="auth-form">
      <input id="authUsername" placeholder="Pseudo" />
      <input id="authPassword" placeholder="Mot de passe" type="password" />
      <div style="display:flex;gap:.5rem;margin-top:1rem;">
        <button id="loginBtn" class="btn" style="flex:1;">Se connecter</button>
      </div>
      <p id="authMsg" class="muted" style="margin-top:1rem;"></p>
    </div>

    <div id="registerForm" class="auth-form hidden">
      <input id="regUsername" placeholder="Pseudo (min. 3 caractères)" />
      <input id="regPassword" placeholder="Mot de passe (min. 6 caractères)" type="password" />
      <input id="regPassword2" placeholder="Répéter mot de passe" type="password" />
      <div style="display:flex;gap:.5rem;margin-top:1rem;">
        <button id="regBtn" class="btn success" style="flex:1;">S'inscrire</button>
      </div>
      <p id="regMsg" class="muted" style="margin-top:1rem;"></p>
    </div>
  </div>

  <div id="modalOverlay" class="modal-overlay hidden"></div>

  <div class="top-right">
    <span id="userInfo" class="muted"></span>
    <button id="logoutBtn" class="btn danger" style="display:none">Déconnexion</button>
    <button id="authBtn" class="btn">Connexion</button>
  </div>

  <header>
    <h1>Anime Forever</h1>
    <nav>
      <button onclick="showSection('home')">Accueil</button>
      <button onclick="showSection('create')">Créer série / épisodes</button>
    </nav>
  </header>

  <main>
    <section id="home">
      <h2>Nos séries</h2>
      <div id="seriesGrid" class="series-grid"></div>
    </section>

    <section id="create" style="display:none">
      <h2>Créer une série</h2>
      <div class="card">
        <label>Pseudo</label>
        <input id="createPseudo" placeholder="Ton pseudo" />
        <label>Nom de la série</label>
        <input id="createName" placeholder="Titre de la série" />
        <label>Description</label>
        <textarea id="createDesc"></textarea>
        <label>Image (URL)</label>
        <input id="createImg" placeholder="https://..." />
        <hr />
        <h3>Épisodes</h3>
        <div id="epBlocks"></div>
        <div style="display:flex;gap:.5rem;margin-top:.5rem">
          <button class="btn" onclick="addEpBlock()">+ Ajouter épisode</button>
          <button class="btn" onclick="clearEpBlocks()">Réinitialiser</button>
        </div>
        <p class="muted">Les fichiers locaux seront uploadés sur le serveur si configuré.</p>
        <div style="margin-top:.6rem">
          <button class="btn" onclick="submitCreate()">Créer la série</button>
        </div>
      </div>
    </section>
  </main>

  <!-- simple modal for series details -->
  <div id="seriesModal" class="modal hidden"></div>

<script>
// =============================================
// BACKEND SIMULÉ INTÉGRÉ - Fonctionne sans serveur
// =============================================

class AnimeForeverBackend {
  constructor() {
    this.users = new Map();
    this.series = new Map();
    this.tokens = new Map();
    this.nextSeriesId = 1;
    this.nextEpisodeId = 1;
    
    // Données d'exemple
    this.initializeSampleData();
  }

  initializeSampleData() {
    // Ajouter un admin par défaut
    this.users.set('admin', {
      username: 'admin',
      password: 'admin123',
      isAdmin: true
    });

    // Ajouter des séries d'exemple
    this.series.set('1', {
      id: '1',
      name: 'Naruto Shippuden',
      desc: 'Suite des aventures de Naruto Uzumaki',
      image: 'https://via.placeholder.com/300x140/1a1a1a/ff3d00?text=Naruto+Shippuden',
      pseudo: 'admin',
      episodes: [
        {
          id: '1-1',
          title: 'Épisode 1: Retour au village',
          src: 'https://example.com/video1.mp4',
          pseudo: 'admin'
        }
      ]
    });

    this.series.set('2', {
      id: '2',
      name: 'Attack on Titan',
      desc: 'Des géants menacent l\'humanité',
      image: 'https://via.placeholder.com/300x140/1a1a1a/00bfa5?text=Attack+on+Titan',
      pseudo: 'admin',
      episodes: [
        {
          id: '2-1',
          title: 'Épisode 1: À vous de mourir',
          src: 'https://example.com/video2.mp4',
          pseudo: 'admin'
        }
      ]
    });
  }

  // Générer un token JWT simulé
  generateToken(username) {
    const token = 'mock-token-' + Date.now() + '-' + Math.random().toString(36).substr(2);
    this.tokens.set(token, username);
    return token;
  }

  verifyToken(token) {
    const username = this.tokens.get(token);
    if (!username) return null;
    
    const user = this.users.get(username);
    if (!user) return null;

    return {
      username: user.username,
      isAdmin: user.isAdmin
    };
  }

  // Méthodes API
  async login(username, password) {
    await this.delay(1000);
    
    const user = this.users.get(username);
    if (!user || user.password !== password) {
      throw new Error('Identifiants incorrects');
    }

    const token = this.generateToken(username);
    return {
      token,
      user: {
        username: user.username,
        isAdmin: user.isAdmin
      }
    };
  }

  async register(username, password) {
    await this.delay(1000);
    
    if (this.users.has(username)) {
      throw new Error('Ce pseudo est déjà pris');
    }

    if (username.length < 3) {
      throw new Error('Le pseudo doit contenir au moins 3 caractères');
    }

    if (password.length < 6) {
      throw new Error('Le mot de passe doit contenir au moins 6 caractères');
    }

    this.users.set(username, {
      username,
      password,
      isAdmin: false
    });

    const token = this.generateToken(username);
    return {
      token,
      user: {
        username,
        isAdmin: false
      }
    };
  }

  async getMe(token) {
    await this.delay(500);
    const user = this.verifyToken(token);
    if (!user) {
      throw new Error('Token invalide');
    }
    return user;
  }

  async getSeries() {
    await this.delay(500);
    return Array.from(this.series.values());
  }

  async createSeries(data, token) {
    await this.delay(500);
    
    const user = this.verifyToken(token);
    if (!user) {
      throw new Error('Non authentifié');
    }

    const seriesId = (this.nextSeriesId++).toString();
    const newSeries = {
      id: seriesId,
      name: data.name,
      desc: data.desc,
      image: data.image,
      pseudo: user.username,
      episodes: []
    };

    this.series.set(seriesId, newSeries);
    return newSeries;
  }

  async addEpisode(seriesId, data, token) {
    await this.delay(500);
    
    const user = this.verifyToken(token);
    if (!user) {
      throw new Error('Non authentifié');
    }

    const series = this.series.get(seriesId);
    if (!series) {
      throw new Error('Série non trouvée');
    }

    const episodeId = seriesId + '-' + (this.nextEpisodeId++);
    const newEpisode = {
      id: episodeId,
      title: data.title || 'Épisode sans titre',
      src: data.src || '#',
      pseudo: user.username
    };

    series.episodes.push(newEpisode);
    return newEpisode;
  }

  async deleteSeries(seriesId, token) {
    await this.delay(500);
    
    const user = this.verifyToken(token);
    if (!user || !user.isAdmin) {
      throw new Error('Action non autorisée');
    }

    if (!this.series.has(seriesId)) {
      throw new Error('Série non trouvée');
    }

    this.series.delete(seriesId);
    return { success: true };
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// =============================================
// FRONTEND - Interface utilisateur
// =============================================

// Initialiser le backend simulé
const backend = new AnimeForeverBackend();
let token = localStorage.getItem('token') || null;
let currentUser = null;

// Fonction fetch qui utilise le backend simulé
async function apiFetch(endpoint, opts = {}) {
  // Simuler un délai réseau
  await new Promise(resolve => setTimeout(resolve, 100));

  try {
    let result;

    switch (endpoint) {
      case '/login':
        if (opts.method === 'POST') {
          const body = JSON.parse(opts.body);
          result = await backend.login(body.username, body.password);
        }
        break;

      case '/register':
        if (opts.method === 'POST') {
          const body = JSON.parse(opts.body);
          result = await backend.register(body.username, body.password);
        }
        break;

      case '/me':
        if (!token) throw new Error('Non authentifié');
        result = await backend.getMe(token);
        break;

      case '/series':
        if (opts.method === 'GET') {
          result = await backend.getSeries();
        } else if (opts.method === 'POST') {
          const body = JSON.parse(opts.body);
          result = await backend.createSeries(body, token);
        }
        break;

      case '/series/episodes':
        if (opts.method === 'POST') {
          const body = JSON.parse(opts.body);
          // Extraire seriesId de l'URL si nécessaire
          const seriesId = body.seriesId;
          result = await backend.addEpisode(seriesId, body, token);
        }
        break;

      default:
        // Gérer les routes avec paramètres comme /series/123
        if (endpoint.startsWith('/series/') && opts.method === 'DELETE') {
          const seriesId = endpoint.split('/')[2];
          result = await backend.deleteSeries(seriesId, token);
        }
        break;
    }

    if (result) {
      return {
        ok: true,
        status: 200,
        json: async () => result
      };
    } else {
      return {
        ok: false,
        status: 404,
        json: async () => ({ error: 'Endpoint non trouvé' })
      };
    }

  } catch (error) {
    return {
      ok: false,
      status: 400,
      json: async () => ({ error: error.message })
    };
  }
}

// Fonction utilitaire pour traiter les réponses
async function handleResponse(response) {
  const data = await response.json();
  
  if (!response.ok) {
    return { success: false, error: data.error || 'Erreur serveur' };
  }

  return { success: true, data };
}

async function loadMe() {
  if (!token) return;
  
  try {
    const response = await apiFetch('/me');
    const result = await handleResponse(response);
    
    if (result.success && result.data.username) {
      currentUser = result.data;
      updateUIAfterAuth();
    } else {
      await handleLogout();
    }
  } catch (e) { 
    console.error('Erreur loadMe:', e);
    await handleLogout();
  }
}

function updateUIAfterAuth() {
  if (currentUser) {
    document.getElementById('userInfo').innerText = currentUser.username + (currentUser.isAdmin ? ' (admin)' : '');
    document.getElementById('logoutBtn').style.display = '';
    document.getElementById('authBtn').style.display = 'none';
    hideAuthModal();
  } else {
    document.getElementById('userInfo').innerText = '';
    document.getElementById('logoutBtn').style.display = 'none';
    document.getElementById('authBtn').style.display = '';
  }
}

async function handleLogout() {
  token = null; 
  localStorage.removeItem('token'); 
  currentUser = null;
  updateUIAfterAuth();
  showAuthModal();
}

function showAuthModal() {
  document.getElementById('authModal').classList.remove('hidden');
  document.getElementById('modalOverlay').classList.remove('hidden');
  switchToLogin();
}

function hideAuthModal() {
  document.getElementById('authModal').classList.add('hidden');
  document.getElementById('modalOverlay').classList.add('hidden');
}

function switchToLogin() {
  document.getElementById('loginTab').classList.add('active');
  document.getElementById('registerTab').classList.remove('active');
  document.getElementById('loginForm').classList.remove('hidden');
  document.getElementById('registerForm').classList.add('hidden');
  clearAuthMessages();
}

function switchToRegister() {
  document.getElementById('registerTab').classList.add('active');
  document.getElementById('loginTab').classList.remove('active');
  document.getElementById('registerForm').classList.remove('hidden');
  document.getElementById('loginForm').classList.add('hidden');
  clearAuthMessages();
}

function clearAuthMessages() {
  document.getElementById('authMsg').innerText = '';
  document.getElementById('authMsg').className = 'muted';
  document.getElementById('regMsg').innerText = '';
  document.getElementById('regMsg').className = 'muted';
}

function showAuthMessage(elementId, message, isError = true) {
  const element = document.getElementById(elementId);
  element.innerText = message;
  element.className = isError ? 'error' : 'success';
}

function setLoading(button, isLoading) {
  if (isLoading) {
    button.classList.add('loading');
    button.disabled = true;
    button.innerHTML = 'Chargement...';
  } else {
    button.classList.remove('loading');
    button.disabled = false;
    button.innerHTML = button === document.getElementById('loginBtn') ? 'Se connecter' : 'S\'inscrire';
  }
}

// Validation functions
function validateUsername(username) {
  if (username.length < 3) {
    return 'Le pseudo doit contenir au moins 3 caractères';
  }
  if (!/^[a-zA-Z0-9_-]+$/.test(username)) {
    return 'Le pseudo ne peut contenir que des lettres, chiffres, tirets et underscores';
  }
  return null;
}

function validatePassword(password) {
  if (password.length < 6) {
    return 'Le mot de passe doit contenir au moins 6 caractères';
  }
  return null;
}

// Authentication event handlers
document.getElementById('loginBtn').addEventListener('click', async () => {
  const username = document.getElementById('authUsername').value.trim();
  const password = document.getElementById('authPassword').value;

  if (!username || !password) {
    return showAuthMessage('authMsg', 'Veuillez remplir tous les champs');
  }

  const usernameError = validateUsername(username);
  if (usernameError) {
    return showAuthMessage('authMsg', usernameError);
  }

  setLoading(document.getElementById('loginBtn'), true);

  try {
    const response = await apiFetch('/login', {
      method: 'POST',
      body: JSON.stringify({ username, password })
    });

    const result = await handleResponse(response);

    if (result.success) {
      token = result.data.token;
      localStorage.setItem('token', token);
      currentUser = result.data.user;
      
      showAuthMessage('authMsg', 'Connexion réussie !', false);
      setTimeout(() => {
        updateUIAfterAuth();
        renderSeries();
      }, 1000);
    } else {
      throw new Error(result.error);
    }

  } catch (error) {
    showAuthMessage('authMsg', error.message);
  } finally {
    setLoading(document.getElementById('loginBtn'), false);
  }
});

document.getElementById('regBtn').addEventListener('click', async () => {
  const username = document.getElementById('regUsername').value.trim();
  const password = document.getElementById('regPassword').value;
  const password2 = document.getElementById('regPassword2').value;

  if (!username || !password || !password2) {
    return showAuthMessage('regMsg', 'Veuillez remplir tous les champs');
  }

  const usernameError = validateUsername(username);
  if (usernameError) {
    return showAuthMessage('regMsg', usernameError);
  }

  const passwordError = validatePassword(password);
  if (passwordError) {
    return showAuthMessage('regMsg', passwordError);
  }

  if (password !== password2) {
    return showAuthMessage('regMsg', 'Les mots de passe ne correspondent pas');
  }

  setLoading(document.getElementById('regBtn'), true);

  try {
    const response = await apiFetch('/register', {
      method: 'POST',
      body: JSON.stringify({ username, password })
    });

    const result = await handleResponse(response);

    if (result.success) {
      token = result.data.token;
      localStorage.setItem('token', token);
      currentUser = result.data.user;
      
      showAuthMessage('regMsg', 'Inscription réussie !', false);
      setTimeout(() => {
        updateUIAfterAuth();
        renderSeries();
      }, 1000);
    } else {
      throw new Error(result.error);
    }

  } catch (error) {
    showAuthMessage('regMsg', error.message);
  } finally {
    setLoading(document.getElementById('regBtn'), false);
  }
});

// Tab switching
document.getElementById('loginTab').addEventListener('click', switchToLogin);
document.getElementById('registerTab').addEventListener('click', switchToRegister);

// Auth button
document.getElementById('authBtn').addEventListener('click', showAuthModal);

// Logout button
document.getElementById('logoutBtn').addEventListener('click', handleLogout);

// Close modal when clicking overlay
document.getElementById('modalOverlay').addEventListener('click', hideAuthModal);

// Navigation et affichage des séries
async function showSection(id) {
  document.querySelectorAll('main > section').forEach(s => s.style.display = 'none');
  document.getElementById(id).style.display = '';
  if (id === 'home') await renderSeries();
  if (id === 'create') {
    document.getElementById('createPseudo').value = currentUser ? currentUser.username : '';
  }
}

async function renderSeries() {
  const grid = document.getElementById('seriesGrid');
  grid.innerHTML = '<p class="muted">Chargement...</p>';
  try {
    const response = await apiFetch('/series');
    const result = await handleResponse(response);
    
    grid.innerHTML = '';
    
    if (result.success) {
      if (!result.data || !result.data.length) {
        grid.innerHTML = '<p class="muted">Aucune série pour le moment.</p>';
        return;
      }
      
      result.data.forEach(s => {
        const el = document.createElement('div'); 
        el.className = 'card';
        el.innerHTML = `
          <img class="series-img" src="${s.image || 'https://via.placeholder.com/300x140/1a1a1a/666666?text=No+Image'}" alt="${s.name}" onerror="this.src='https://via.placeholder.com/300x140/1a1a1a/666666?text=Image+Error'">
          <h3>${s.name}</h3>
          <p class="muted">${s.desc || ''}</p>
          <p class="muted">Ajouté par : ${s.pseudo}</p>
          <div style="display:flex;gap:.5rem;margin-top:.5rem">
            <button class="btn" onclick='openSeries("${s.id}")'>Voir</button>
            ${ (currentUser && currentUser.isAdmin) ? `<button class="btn danger" onclick='deleteSeries("${s.id}")'>Supprimer</button>` : ''}
          </div>
        `;
        grid.appendChild(el);
      });
    } else {
      grid.innerHTML = `<p class="error">${result.error}</p>`;
    }
  } catch (error) {
    console.error('Erreur renderSeries:', error);
    grid.innerHTML = '<p class="error">Erreur de chargement des séries</p>';
  }
}

// FONCTIONS MANQUANTES AJOUTÉES :

async function openSeries(id) {
  try {
    const response = await apiFetch('/series');
    const result = await handleResponse(response);
    
    if (!result.success) {
      alert('Erreur: ' + result.error);
      return;
    }

    const s = result.data.find(x => x.id === id);
    if (!s) {
      alert('Série introuvable');
      return;
    }

    const modal = document.getElementById('seriesModal');
    let html = `
      <h2>${s.name}</h2>
      <p>${s.desc || ''}</p>
      <img src="${s.image || 'https://via.placeholder.com/200x140/1a1a1a/666666?text=No+Image'}" style="max-width:200px;border-radius:6px" onerror="this.src='https://via.placeholder.com/200x140/1a1a1a/666666?text=Image+Error'">
      <hr>
      <h3>Épisodes</h3>
    `;
    
    if (s.episodes && s.episodes.length > 0) {
      s.episodes.forEach(ep => {
        html += `
          <div class="episode">
            <div>
              <strong>${ep.title || 'Épisode sans titre'}</strong> 
              <div class="muted">par ${ep.pseudo}</div>
            </div>
            <div style="display:flex;gap:.4rem">
              <a class="btn" href="${ep.src}" target="_blank">Regarder</a>
              ${ (currentUser && currentUser.isAdmin) ? `<button class="btn danger" onclick='deleteEpisode("${s.id}","${ep.id}")'>Supprimer</button>` : '' }
            </div>
          </div>`;
      });
    } else {
      html += '<p class="muted">Aucun épisode pour le moment.</p>';
    }
    
    html += `
      <hr><h4>Ajouter un épisode</h4>
      <div>
        <input id="addEpTitle" placeholder="Titre (optionnel)"/>
        <input id="addEpSrc" placeholder="URL vidéo"/>
        <div style="margin-top:.5rem">
          <button class="btn" onclick='addEpisodeToSeries("${s.id}")'>Ajouter</button>
        </div>
      </div>
      <hr><button class="btn" onclick="closeSeries()">Fermer</button>
    `;
    
    modal.innerHTML = html;
    modal.classList.remove('hidden');
    document.getElementById('modalOverlay').classList.remove('hidden');
  } catch (error) {
    alert('Erreur lors du chargement de la série');
    console.error(error);
  }
}

function closeSeries() {
  const modal = document.getElementById('seriesModal');
  modal.classList.add('hidden');
  document.getElementById('modalOverlay').classList.add('hidden');
  modal.innerHTML = '';
  renderSeries();
}

async function deleteSeries(id) {
  if (!confirm('Supprimer la série et tous ses épisodes ?')) return;
  
  try {
    const response = await apiFetch(`/series/${id}`, { method: 'DELETE' });
    const result = await handleResponse(response);
    
    if (result.success) {
      alert('Série supprimée');
      renderSeries();
    } else {
      alert('Erreur: ' + result.error);
    }
  } catch (error) {
    alert('Erreur: ' + error.message);
  }
}

async function deleteEpisode(seriesId, epId) {
  if (!confirm('Supprimer cet épisode ?')) return;
  alert('Fonction de suppression d\'épisode - En développement');
  // Implémentation future
}

async function addEpisodeToSeries(seriesId) {
  const title = document.getElementById('addEpTitle').value.trim();
  const src = document.getElementById('addEpSrc').value.trim();
  
  if (!src) {
    return alert('URL vidéo requise');
  }

  try {
    const response = await apiFetch('/series/episodes', {
      method: 'POST',
      body: JSON.stringify({ 
        seriesId: seriesId,
        title: title,
        src: src
      })
    });

    const result = await handleResponse(response);

    if (result.success) {
      alert('Épisode ajouté !');
      closeSeries();
      openSeries(seriesId); // Recharger la modal
    } else {
      alert('Erreur: ' + result.error);
    }
  } catch (error) {
    alert('Erreur: ' + error.message);
  }
}

// Fonctions pour les épisodes
function addEpBlock() {
  const list = document.getElementById('epBlocks');
  const div = document.createElement('div');
  div.className = 'episode-block';
  div.innerHTML = `
    <input class="epTitle" placeholder="Titre épisode (optionnel)"/>
    <input class="epUrl" placeholder="Lien vidéo"/>
    <input type="file" class="epFile"/>
  `;
  list.appendChild(div);
}

function clearEpBlocks() {
  document.getElementById('epBlocks').innerHTML = '';
}

async function submitCreate() {
  const pseudo = document.getElementById('createPseudo').value.trim();
  const name = document.getElementById('createName').value.trim();
  const desc = document.getElementById('createDesc').value.trim();
  const image = document.getElementById('createImg').value.trim();
  
  if (!pseudo || !name) {
    return alert('Pseudo et nom de série requis');
  }

  try {
    const response = await apiFetch('/series', {
      method: 'POST',
      body: JSON.stringify({ name, desc, image, pseudo })
    });

    const result = await handleResponse(response);

    if (result.success) {
      alert('Série créée avec succès!');
      document.getElementById('createName').value = '';
      document.getElementById('createDesc').value = '';
      document.getElementById('createImg').value = '';
      clearEpBlocks();
      showSection('home');
    } else {
      alert('Erreur: ' + result.error);
    }
  } catch (error) {
    alert('Erreur: ' + error.message);
  }
}

// Initialisation
(async () => {
  console.log('Anime Forever - Backend simulé intégré');
  console.log('Compte admin disponible: admin / admin123');
  
  if (token) {
    await loadMe();
  }
  addEpBlock();
  await renderSeries();
})();
</script>
</body>
</html>
  
