<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Anime Forever</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@400;700&display=swap');
    :root { --bg:#0d0d0d; --card:#1a1a1a; --accent:#ff3d00; --muted:#ccc; --success:#4caf50; --error:#f44336; }
    body{margin:0;font-family:'Nunito Sans',sans-serif;background:var(--bg);color:#f0f0f0}
    header{background:var(--card);padding:1rem;display:flex;justify-content:space-between;align-items:center}
    header h1{color:var(--accent);margin:0}
    nav button{background:var(--accent);border:none;color:#fff;padding:.5rem 1rem;border-radius:6px;cursor:pointer;margin-left:0.5rem;}
    nav button:hover{opacity:0.9;}
    main{padding:1rem}
    .series-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:1rem}
    .card{background:var(--card);padding:1rem;border-radius:10px;box-shadow:0 2px 6px rgba(0,0,0,.5)}
    img.series-img{width:100%;height:140px;object-fit:cover;border-radius:6px}
    .episode{background:#222;padding:.5rem;border-radius:6px;margin-bottom:.5rem;display:flex;justify-content:space-between;align-items:center}
    input,select,textarea{width:100%;padding:.5rem;border-radius:6px;border:none;margin:.4rem 0;box-sizing:border-box;background:#333;color:white;}
    .btn{background:#00bfa5;color:#fff;border:none;padding:.6rem 1rem;border-radius:6px;cursor:pointer;transition:opacity 0.2s;}
    .btn:hover{opacity:0.9;}
    .btn:disabled{opacity:0.6;cursor:not-allowed;}
    .danger{background:#e53935}
    .success{background:var(--success)}
    .muted{color:var(--muted)}
    .error{color:var(--error)}
    .success{color:var(--success)}
    .hidden{display:none}
    .top-right{position:fixed;right:1rem;top:1rem;z-index:2000;display:flex;align-items:center;gap:0.5rem;}
    .modal{position:fixed;left:50%;top:50%;transform:translate(-50%, -50%);width:90%;max-width:400px;background:#1a1a1a;padding:2rem;border-radius:8px;z-index:9999;box-shadow:0 0 20px rgba(0,0,0,0.7);}
    .modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:9998;}
    .auth-tabs{display:flex;margin-bottom:1rem;border-bottom:1px solid #333;}
    .auth-tab{padding:0.5rem 1rem;cursor:pointer;border-bottom:2px solid transparent;}
    .auth-tab.active{color:var(--accent);border-bottom-color:var(--accent);}
    .auth-form{display:block;}
    .auth-form.hidden{display:none;}
    .loading{opacity:0.6;pointer-events:none;}
  </style>
</head>
<body>
  <!-- auth modal -->
  <div id="authModal" class="modal hidden">
    <div class="auth-tabs">
      <div class="auth-tab active" id="loginTab">Connexion</div>
      <div class="auth-tab" id="registerTab">Inscription</div>
    </div>

    <div id="loginForm" class="auth-form">
      <input id="authUsername" placeholder="Pseudo" />
      <input id="authPassword" placeholder="Mot de passe" type="password" />
      <div style="display:flex;gap:.5rem;margin-top:1rem;">
        <button id="loginBtn" class="btn" style="flex:1;">Se connecter</button>
      </div>
      <p id="authMsg" class="muted" style="margin-top:1rem;"></p>
    </div>

    <div id="registerForm" class="auth-form hidden">
      <input id="regUsername" placeholder="Pseudo (min. 3 caractères)" />
      <input id="regPassword" placeholder="Mot de passe (min. 6 caractères)" type="password" />
      <input id="regPassword2" placeholder="Répéter mot de passe" type="password" />
      <div style="display:flex;gap:.5rem;margin-top:1rem;">
        <button id="regBtn" class="btn success" style="flex:1;">S'inscrire</button>
      </div>
      <p id="regMsg" class="muted" style="margin-top:1rem;"></p>
    </div>
  </div>

  <div id="modalOverlay" class="modal-overlay hidden"></div>

  <div class="top-right">
    <span id="userInfo" class="muted"></span>
    <button id="logoutBtn" class="btn danger" style="display:none">Déconnexion</button>
    <button id="authBtn" class="btn">Connexion</button>
  </div>

  <header>
    <h1>Anime Forever</h1>
    <nav>
      <button onclick="showSection('home')">Accueil</button>
      <button onclick="showSection('create')">Créer série / épisodes</button>
    </nav>
  </header>

  <main>
    <section id="home">
      <h2>Nos séries</h2>
      <div id="seriesGrid" class="series-grid"></div>
    </section>

    <section id="create" style="display:none">
      <h2>Créer une série</h2>
      <div class="card">
        <label>Pseudo</label>
        <input id="createPseudo" placeholder="Ton pseudo" />
        <label>Nom de la série</label>
        <input id="createName" placeholder="Titre de la série" />
        <label>Description</label>
        <textarea id="createDesc"></textarea>
        <label>Image (URL)</label>
        <input id="createImg" placeholder="https://..." />
        <hr />
        <h3>Épisodes</h3>
        <div id="epBlocks"></div>
        <div style="display:flex;gap:.5rem;margin-top:.5rem">
          <button class="btn" onclick="addEpBlock()">+ Ajouter épisode</button>
          <button class="btn" onclick="clearEpBlocks()">Réinitialiser</button>
        </div>
        <p class="muted">Les fichiers locaux seront uploadés sur le serveur si configuré.</p>
        <div style="margin-top:.6rem">
          <button class="btn" onclick="submitCreate()">Créer la série</button>
        </div>
      </div>
    </section>
  </main>

  <!-- simple modal for series details -->
  <div id="seriesModal" class="modal hidden"></div>

<script>
// Configuration de base - SIMULATION d'API si le backend n'est pas disponible
const API_ROOT = ''; 
let token = localStorage.getItem('token') || null;
let currentUser = null;

// Simulation d'API pour le développement
const mockAPI = {
  async login(username, password) {
    await new Promise(resolve => setTimeout(resolve, 1000));
    if (username === 'admin' && password === 'admin') {
      return {
        token: 'mock-jwt-token-' + Date.now(),
        user: { username: 'admin', isAdmin: true }
      };
    }
    if (username === 'test' && password === 'test123') {
      return {
        token: 'mock-jwt-token-' + Date.now(),
        user: { username: 'test', isAdmin: false }
      };
    }
    throw new Error('Identifiants incorrects');
  },

  async register(username, password) {
    await new Promise(resolve => setTimeout(resolve, 1000));
    if (username.length < 3) {
      throw new Error('Le pseudo doit contenir au moins 3 caractères');
    }
    if (password.length < 6) {
      throw new Error('Le mot de passe doit contenir au moins 6 caractères');
    }
    if (username === 'admin') {
      throw new Error('Ce pseudo est réservé');
    }
    return {
      token: 'mock-jwt-token-' + Date.now(),
      user: { username, isAdmin: false }
    };
  },

  async getMe(token) {
    await new Promise(resolve => setTimeout(resolve, 500));
    if (token && token.includes('mock-jwt-token')) {
      const username = token.includes('admin') ? 'admin' : 'test';
      return { username, isAdmin: username === 'admin' };
    }
    throw new Error('Token invalide');
  },

  async getSeries() {
    await new Promise(resolve => setTimeout(resolve, 500));
    return [
      {
        id: '1',
        name: 'Naruto Shippuden',
        desc: 'Suite des aventures de Naruto',
        image: 'https://via.placeholder.com/300x140/1a1a1a/ff3d00?text=Naruto',
        pseudo: 'admin',
        episodes: [
          { id: '1-1', title: 'Épisode 1: Retour au village', src: '#', pseudo: 'admin' },
          { id: '1-2', title: 'Épisode 2: L\'équipe Kakashi', src: '#', pseudo: 'admin' }
        ]
      },
      {
        id: '2', 
        name: 'Attack on Titan',
        desc: 'Des géants menacent l\'humanité',
        image: 'https://via.placeholder.com/300x140/1a1a1a/00bfa5?text=Attack+on+Titan',
        pseudo: 'test',
        episodes: [
          { id: '2-1', title: 'Épisode 1: À vous de mourir', src: '#', pseudo: 'test' }
        ]
      }
    ];
  }
};

// Fonction fetch améliorée avec gestion d'erreurs
async function apiFetch(url, opts = {}) {
  // Si pas de backend, utiliser les mocks
  if (!window.hasBackend) {
    const mockMethod = url.replace('/api/', '').split('/')[0];
    if (mockAPI[mockMethod]) {
      try {
        const result = await mockAPI[mockMethod](...Object.values(opts.body || {}));
        return {
          ok: true,
          json: () => Promise.resolve(result),
          text: () => Promise.resolve(JSON.stringify(result))
        };
      } catch (error) {
        return {
          ok: false,
          json: () => Promise.resolve({ error: error.message }),
          status: 400
        };
      }
    }
  }

  // Sinon, faire une vraie requête
  opts.headers = opts.headers || {};
  if (token && !url.includes('/login') && !url.includes('/register')) {
    opts.headers['Authorization'] = 'Bearer ' + token;
  }
  
  if (opts.body && typeof opts.body === 'object' && !(opts.body instanceof FormData)) {
    opts.headers['Content-Type'] = 'application/json';
    opts.body = JSON.stringify(opts.body);
  }

  try {
    const response = await fetch(API_ROOT + url, opts);
    
    // Vérifier si la réponse est du JSON valide
    const text = await response.text();
    let data;
    try {
      data = text ? JSON.parse(text) : {};
    } catch (e) {
      console.error('Réponse non-JSON:', text);
      throw new Error('Réponse serveur invalide');
    }
    
    // Retourner un objet response simulé avec les données
    return {
      ok: response.ok,
      status: response.status,
      json: () => Promise.resolve(data),
      text: () => Promise.resolve(text)
    };
  } catch (error) {
    console.error('Erreur fetch:', error);
    // Retourner une réponse d'erreur simulée
    return {
      ok: false,
      status: 0,
      json: () => Promise.resolve({ error: 'Erreur de connexion' }),
      text: () => Promise.resolve('{ "error": "Erreur de connexion" }')
    };
  }
}

async function loadMe() {
  if (!token) return;
  try {
    const res = await apiFetch('/api/me');
    const json = await res.json();
    
    if (res.ok && json.username) {
      currentUser = json;
      updateUIAfterAuth();
    } else {
      await handleLogout();
    }
  } catch (e) { 
    console.error('Erreur loadMe:', e);
    await handleLogout();
  }
}

function updateUIAfterAuth() {
  if (currentUser) {
    document.getElementById('userInfo').innerText = currentUser.username + (currentUser.isAdmin ? ' (admin)' : '');
    document.getElementById('logoutBtn').style.display = '';
    document.getElementById('authBtn').style.display = 'none';
    hideAuthModal();
  } else {
    document.getElementById('userInfo').innerText = '';
    document.getElementById('logoutBtn').style.display = 'none';
    document.getElementById('authBtn').style.display = '';
  }
}

async function handleLogout() {
  token = null; 
  localStorage.removeItem('token'); 
  currentUser = null;
  updateUIAfterAuth();
  showAuthModal();
}

function showAuthModal() {
  document.getElementById('authModal').classList.remove('hidden');
  document.getElementById('modalOverlay').classList.remove('hidden');
  switchToLogin();
}

function hideAuthModal() {
  document.getElementById('authModal').classList.add('hidden');
  document.getElementById('modalOverlay').classList.add('hidden');
}

function switchToLogin() {
  document.getElementById('loginTab').classList.add('active');
  document.getElementById('registerTab').classList.remove('active');
  document.getElementById('loginForm').classList.remove('hidden');
  document.getElementById('registerForm').classList.add('hidden');
  clearAuthMessages();
}

function switchToRegister() {
  document.getElementById('registerTab').classList.add('active');
  document.getElementById('loginTab').classList.remove('active');
  document.getElementById('registerForm').classList.remove('hidden');
  document.getElementById('loginForm').classList.add('hidden');
  clearAuthMessages();
}

function clearAuthMessages() {
  document.getElementById('authMsg').innerText = '';
  document.getElementById('authMsg').className = 'muted';
  document.getElementById('regMsg').innerText = '';
  document.getElementById('regMsg').className = 'muted';
}

function showAuthMessage(elementId, message, isError = true) {
  const element = document.getElementById(elementId);
  element.innerText = message;
  element.className = isError ? 'error' : 'success';
}

function setLoading(button, isLoading) {
  if (isLoading) {
    button.classList.add('loading');
    button.disabled = true;
    button.innerHTML = 'Chargement...';
  } else {
    button.classList.remove('loading');
    button.disabled = false;
    button.innerHTML = button === document.getElementById('loginBtn') ? 'Se connecter' : 'S\'inscrire';
  }
}

// Validation functions
function validateUsername(username) {
  if (username.length < 3) {
    return 'Le pseudo doit contenir au moins 3 caractères';
  }
  if (!/^[a-zA-Z0-9_-]+$/.test(username)) {
    return 'Le pseudo ne peut contenir que des lettres, chiffres, tirets et underscores';
  }
  return null;
}

function validatePassword(password) {
  if (password.length < 6) {
    return 'Le mot de passe doit contenir au moins 6 caractères';
  }
  return null;
}

// Authentication event handlers
document.getElementById('loginBtn').addEventListener('click', async () => {
  const username = document.getElementById('authUsername').value.trim();
  const password = document.getElementById('authPassword').value;

  if (!username || !password) {
    return showAuthMessage('authMsg', 'Veuillez remplir tous les champs');
  }

  const usernameError = validateUsername(username);
  if (usernameError) {
    return showAuthMessage('authMsg', usernameError);
  }

  setLoading(document.getElementById('loginBtn'), true);

  try {
    const res = await apiFetch('/api/login', { 
      method: 'POST',
      body: { username, password }
    });
    
    const data = await res.json();
    
    if (!res.ok) {
      throw new Error(data.error || 'Erreur de connexion');
    }

    token = data.token;
    localStorage.setItem('token', token);
    currentUser = data.user;
    
    showAuthMessage('authMsg', 'Connexion réussie !', false);
    setTimeout(() => {
      updateUIAfterAuth();
      renderSeries();
    }, 1000);

  } catch (error) {
    showAuthMessage('authMsg', error.message);
  } finally {
    setLoading(document.getElementById('loginBtn'), false);
  }
});

document.getElementById('regBtn').addEventListener('click', async () => {
  const username = document.getElementById('regUsername').value.trim();
  const password = document.getElementById('regPassword').value;
  const password2 = document.getElementById('regPassword2').value;

  if (!username || !password || !password2) {
    return showAuthMessage('regMsg', 'Veuillez remplir tous les champs');
  }

  const usernameError = validateUsername(username);
  if (usernameError) {
    return showAuthMessage('regMsg', usernameError);
  }

  const passwordError = validatePassword(password);
  if (passwordError) {
    return showAuthMessage('regMsg', passwordError);
  }

  if (password !== password2) {
    return showAuthMessage('regMsg', 'Les mots de passe ne correspondent pas');
  }

  setLoading(document.getElementById('regBtn'), true);

  try {
    const res = await apiFetch('/api/register', { 
      method: 'POST',
      body: { username, password }
    });
    
    const data = await res.json();
    
    if (!res.ok) {
      throw new Error(data.error || 'Erreur d\'inscription');
    }

    token = data.token;
    localStorage.setItem('token', token);
    currentUser = data.user;
    
    showAuthMessage('regMsg', 'Inscription réussie !', false);
    setTimeout(() => {
      updateUIAfterAuth();
      renderSeries();
    }, 1000);

  } catch (error) {
    showAuthMessage('regMsg', error.message);
  } finally {
    setLoading(document.getElementById('regBtn'), false);
  }
});

// Tab switching
document.getElementById('loginTab').addEventListener('click', switchToLogin);
document.getElementById('registerTab').addEventListener('click', switchToRegister);

// Auth button
document.getElementById('authBtn').addEventListener('click', showAuthModal);

// Logout button
document.getElementById('logoutBtn').addEventListener('click', handleLogout);

// Close modal when clicking overlay
document.getElementById('modalOverlay').addEventListener('click', hideAuthModal);

// Navigation et affichage des séries
async function showSection(id) {
  document.querySelectorAll('main > section').forEach(s => s.style.display = 'none');
  document.getElementById(id).style.display = '';
  if (id === 'home') await renderSeries();
  if (id === 'create') {
    document.getElementById('createPseudo').value = currentUser ? currentUser.username : '';
  }
}

async function renderSeries() {
  const grid = document.getElementById('seriesGrid');
  grid.innerHTML = '<p class="muted">Chargement...</p>';
  try {
    const res = await apiFetch('/api/series');
    const data = await res.json();
    
    grid.innerHTML = '';
    if (!data || !data.length) {
      grid.innerHTML = '<p class="muted">Aucune série pour le moment.</p>';
      return;
    }
    
    data.forEach(s => {
      const el = document.createElement('div'); 
      el.className = 'card';
      el.innerHTML = `
        <img class="series-img" src="${s.image || 'https://via.placeholder.com/300x140/1a1a1a/666666?text=No+Image'}" alt="${s.name}" onerror="this.src='https://via.placeholder.com/300x140/1a1a1a/666666?text=Image+Error'">
        <h3>${s.name}</h3>
        <p class="muted">${s.desc || ''}</p>
        <p class="muted">Ajouté par : ${s.pseudo}</p>
        <div style="display:flex;gap:.5rem;margin-top:.5rem">
          <button class="btn" onclick='openSeries("${s.id}")'>Voir</button>
          ${ (currentUser && currentUser.isAdmin) ? `<button class="btn danger" onclick='deleteSeries("${s.id}")'>Supprimer</button>` : ''}
        </div>
      `;
      grid.appendChild(el);
    });
  } catch (error) {
    console.error('Erreur renderSeries:', error);
    grid.innerHTML = '<p class="muted">Erreur de chargement des séries.</p>';
  }
}

// Fonctions pour les épisodes (simplifiées pour la démo)
function addEpBlock() {
  const list = document.getElementById('epBlocks');
  const div = document.createElement('div');
  div.className = 'episode-block';
  div.innerHTML = `
    <input class="epTitle" placeholder="Titre épisode (optionnel)"/>
    <input class="epUrl" placeholder="Lien vidéo"/>
    <input type="file" class="epFile"/>
  `;
  list.appendChild(div);
}

function clearEpBlocks() {
  document.getElementById('epBlocks').innerHTML = '';
}

function submitCreate() {
  alert('Fonction de création - Mode démonstration');
  showSection('home');
}

// Initialisation
(async () => {
  // Tester si le backend est disponible
  try {
    const testRes = await fetch(API_ROOT + '/api/series');
    window.hasBackend = testRes.ok;
  } catch (e) {
    window.hasBackend = false;
    console.log('Mode démonstration activé - pas de backend détecté');
  }

  if (token) {
    await loadMe();
  }
  addEpBlock();
  await renderSeries();
})();
</script>
</body>
</html>
